
/*
 This file was autogenerated via
 -----------------------------------------------------------------
 ldetool generate --little-endian --package ldetesting parsing.lde
 -----------------------------------------------------------------
 do not touch it with bare hands!
*/

package ldetesting

import (
	"bytes"
	"fmt"
	"github.com/sirkon/decconv"
	"strconv"
	"unsafe"
)

var ab = []byte("ab")
var abcd = []byte("abcd")
var ba = []byte("ba")
var bar = []byte("|")
var const123456789 = []byte("123456789")
var const34 = []byte("34")
var dogs = []byte("@@")
var ee = []byte("ee")
var ll = []byte("ll")
var space = []byte(" ")

// Decoders ...
type Decoders struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *Decoders) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimited ...
type DecodersLimited struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimited) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(tmpRest))
	}

	return true, nil
}

// DecodersBounded ...
type DecodersBounded struct {
	Rest  []byte
	Int64 int64
}

// Extract ...
func (p *DecodersBounded) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	var tmpRest []byte

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+1+8:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersString ...
type DecodersString struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimitedString ...
type DecodersLimitedString struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until " " as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersBoundedString ...
type DecodersBoundedString struct {
	Rest    []byte
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpRest []byte

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+len(space)+8:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecodersStress ...
type DecodersStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.Rest))
	}

	return true, nil
}

// DecodersLimitedStress ...
type DecodersLimitedStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(tmpRest))
	}

	return true, nil
}

// DecodersBoundedStress ...
type DecodersBoundedStress struct {
	Rest  []byte
	Int64 int64
}

// Extract ...
func (p *DecodersBoundedStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	var tmpRest []byte

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+1+8:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersStringStress ...
type DecodersStringStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersStringStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.Rest))
	}

	return true, nil
}

// DecodersLimitedStringStress ...
type DecodersLimitedStringStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedStringStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until " " as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int16(int16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int32(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int64(int64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint8(uint8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint16(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint32(uint32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Uint64(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float32(float32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(tmpRest))
	}

	return true, nil
}

// DecodersBoundedStringStress ...
type DecodersBoundedStringStress struct {
	Rest    []byte
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedStringStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpRest []byte

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.Index(tmpRest, space)
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+len(space)+8:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Float64(float64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecoderOptionals ...
type DecoderOptionals struct {
	Rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderOptionals) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var rest1 []byte
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)
	rest1 = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(rest1) >= 5 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffffff == 0x3d64616568 {
		rest1 = rest1[5:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}
	p.Head.Valid = true
	p.Rest = rest1
decoderoptionalsHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if len(p.Rest) >= 3 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffff == 0x646e65 {
		p.Rest = p.Rest[3:]
	} else {
		return false, nil
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionals) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderOptionalsStress ...
type DecoderOptionalsStress struct {
	Rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderOptionalsStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var rest1 []byte
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Int8(int8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Int8 = int8(tmpInt)
	rest1 = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(rest1) >= 5 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffffff == 0x3d64616568 {
		rest1 = rest1[5:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}
	p.Head.Valid = true
	p.Rest = rest1
decoderoptionalsstressHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if len(p.Rest) >= 3 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffff == 0x646e65 {
		p.Rest = p.Rest[3:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest), "end")
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionalsStress) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranching ...
type DecoderBranching struct {
	Rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderBranching) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var rest1 []byte

	// Checks if the rest starts with `"start "` and pass it
	if len(p.Rest) >= 6 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffffffffff == 0x207472617473 {
		p.Rest = p.Rest[6:]
	}
	rest1 = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(rest1) >= 5 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffffff == 0x3d64616568 {
		rest1 = rest1[5:]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Head.Valid = true
	p.Rest = rest1

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranching) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranchingStress ...
type DecoderBranchingStress struct {
	Rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderBranchingStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var rest1 []byte

	// Checks if the rest starts with `"start "` and pass it
	if len(p.Rest) >= 6 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffffffffff == 0x207472617473 {
		p.Rest = p.Rest[6:]
	}
	rest1 = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(rest1) >= 5 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffffff == 0x3d64616568 {
		rest1 = rest1[5:]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Head.Valid = true
	p.Rest = rest1

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranchingStress) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DoubleOpts ...
type DoubleOpts struct {
	Rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
	Rest1 struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DoubleOpts) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var rest1 []byte
	rest1 = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(rest1) >= 5 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffffff == 0x3d64616568 {
		rest1 = rest1[5:]
	} else {
		p.Head.Valid = false
		goto doubleoptsHeadLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Head.Valid = true
	p.Rest = rest1
doubleoptsHeadLabel:
	rest1 = p.Rest

	// Checks if the rest starts with `"rest="` and pass it
	if len(rest1) >= 5 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffffff == 0x3d74736572 {
		rest1 = rest1[5:]
	} else {
		p.Rest1.Valid = false
		goto doubleoptsRest1Label
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Rest1.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Rest1.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Rest1.Valid = true
	p.Rest = rest1
doubleoptsRest1Label:

	return true, nil
}

// GetHeadData ...
func (p *DoubleOpts) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// GetRest1Data ...
func (p *DoubleOpts) GetRest1Data() (res []byte) {
	if p.Rest1.Valid {
		res = p.Rest1.Data
	}
	return
}

// Prefixes ...
type Prefixes struct {
	Rest  []byte
	Data  int32
	Rest1 int32
}

// Extract ...
func (p *Prefixes) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Checks if the rest starts with `"123456789"` and pass it
	if bytes.HasPrefix(p.Rest, const123456789) {
		p.Rest = p.Rest[len(const123456789):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest), "123456789")
	}

	// Take until ' ' as Data(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Data(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Data = int32(tmpInt)

	// Checks if the rest starts with `"12345"` and pass it
	if len(p.Rest) >= 5 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffffffff == 0x3534333231 {
		p.Rest = p.Rest[5:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest), "12345")
	}

	// Take until ' ' as Rest1(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest1", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Rest1(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Rest1 = int32(tmpInt)

	return true, nil
}

// FixedLook ...
type FixedLook struct {
	Rest  []byte
	Data  int32
	Rest1 int32
}

// Extract ...
func (p *FixedLook) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until 3rd  if it starts "123456789" substring as Data(int32)
	if len(p.Rest) >= len(const123456789)+2 && bytes.HasPrefix(p.Rest[2:], const123456789) {
		pos = 2
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(const123456789):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", const123456789, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Data(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Data = int32(tmpInt)

	// Take until 4th  if it starts "34" substring as Rest1(int32)
	if len(p.Rest)-3 >= 2 && *(*uint64)(unsafe.Pointer(&p.Rest[3]))&0xffff == 0x3433 {
		pos = 3
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(const34):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest1", const34, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Rest1(int32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Rest1 = int32(tmpInt)

	return true, nil
}

// AnonymousAreas ...
type AnonymousAreas struct {
	Rest []byte
	Data []byte
}

// Extract ...
func (p *AnonymousAreas) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var rest1 []byte
	rest1 = p.Rest

	// Looking for 'd' and then pass it
	pos = -1
	for i, char := range rest1 {
		if char == 'd' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		rest1 = rest1[pos+1:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}

	// Checks if the rest starts with `"ata="` and pass it
	if len(rest1) >= 4 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffff == 0x3d617461 {
		rest1 = rest1[4:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}
	p.Rest = rest1
anonymousareasAnonymousAreaLabel:
	rest1 = p.Rest

	// Checks if the rest starts with `"1234"` and pass it
	if len(rest1) >= 4 && *(*uint64)(unsafe.Pointer(&rest1[0]))&0xffffffff == 0x34333231 {
		rest1 = rest1[4:]
	} else {
		goto anonymousareasAnonymousAreaLabel2
	}
	p.Rest = rest1
anonymousareasAnonymousAreaLabel2:

	// Take until " " (or all the rest if not found) as Data(string)
	pos = bytes.Index(p.Rest, space)
	if pos >= 0 {
		p.Data = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(space):]
	} else {
		p.Data = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}

	return true, nil
}

// Split ...
type Split struct {
	Rest  []byte
	Name  []byte
	Count []byte
}

// Extract ...
func (p *Split) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Take until '|' as Name(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Name = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Name", '|', string(p.Rest))
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		p.Rest = p.Rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.Rest), "'|'")
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		p.Rest = p.Rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.Rest), "'|'")
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		p.Rest = p.Rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.Rest), "'|'")
	}

	// Take until 2nd character if it is'|' as Count(string)
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		pos = 1
	} else {
		pos = -1
	}
	if pos >= 0 {
		p.Count = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Count", '|', string(p.Rest))
	}

	return true, nil
}

// Shift1 ...
type Shift1 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift1) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until "ba" as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = bytes.Index(tmpRest, ba)
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+len(ba)+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field B", ba, string(tmpRest))
	}

	return true, nil
}

// Shift2 ...
type Shift2 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift2) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until 'b' as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = bytes.IndexByte(tmpRest, 'b')
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+1+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field B", 'b', string(tmpRest))
	}

	return true, nil
}

// Shift3 ...
type Shift3 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift3) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until "ba" as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = bytes.Index(tmpRest, ba)
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+len(ba)+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field B", ba, string(tmpRest))
	}

	return true, nil
}

// Shift4 ...
type Shift4 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift4) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until 'b' as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = -1
	for i, char := range tmpRest {
		if char == 'b' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+1+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field B", 'b', string(tmpRest))
	}

	return true, nil
}

// Jump ...
type Jump struct {
	Rest   []byte
	First  []byte
	Second []byte
	Third  []byte
	Fourth []byte
}

// Extract ...
func (p *Jump) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Take until ' ' as First(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.IndexByte(p.Rest[2:], ' ')
	if pos >= 0 {
		p.First = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field First", ' ', string(p.Rest[2:]))
	}

	// Take until ' ' as Second(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = -1
	for i, char := range p.Rest[2:] {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Second = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Second", ' ', string(p.Rest[2:]))
	}

	// Take until "@@" as Third(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.Index(p.Rest[2:], dogs)
	if pos >= 0 {
		p.Third = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+len(dogs)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Third", dogs, string(p.Rest[2:]))
	}

	// Take until "@@" as Fourth(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.Index(p.Rest[2:], dogs)
	if pos >= 0 {
		p.Fourth = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+len(dogs)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Fourth", dogs, string(p.Rest[2:]))
	}

	return true, nil
}

// LookupJump ...
type LookupJump struct {
	Rest []byte
}

// Extract ...
func (p *LookupJump) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Looking for ' ' and then pass it
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.IndexByte(p.Rest[2:], ' ')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "' '", string(p.Rest[2:]))
	}

	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	// Looking for "@@" and then pass it
	pos = bytes.Index(p.Rest[2:], dogs)
	if pos >= 0 {
		p.Rest = p.Rest[pos+len(dogs)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", dogs, string(p.Rest[2:]))
	}

	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[:12]
	} else {
		tmpRest = p.Rest
	}
	// Looking for "ll" and then pass it
	pos = bytes.Index(tmpRest, ll)
	if pos >= 0 {
		p.Rest = p.Rest[pos+len(ll):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", ll, string(tmpRest))
	}

	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[2:12]
	} else {
		tmpRest = p.Rest[2:]
	}
	// Looking for "ee" and then pass it
	pos = bytes.Index(tmpRest, ee)
	if pos >= 0 {
		p.Rest = p.Rest[pos+len(ee)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", ee, string(tmpRest))
	}

	// Looking for 'e' and then pass it
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[:12]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, 'e')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "'e'", string(tmpRest))
	}

	// Looking for 'f' and then pass it
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[2:12]
	} else {
		tmpRest = p.Rest[2:]
	}
	pos = bytes.IndexByte(tmpRest, 'f')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "'f'", string(tmpRest))
	}

	return true, nil
}

// TargetConstraintsCheck ...
type TargetConstraintsCheck struct {
	Rest []byte
}

// Extract ...
func (p *TargetConstraintsCheck) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Looking for ' ' and then pass it
	if len(p.Rest) < 1 {
		return false, nil
	}
	pos = bytes.IndexByte(p.Rest[1:], ' ')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+1:]
	} else {
		return false, nil
	}

	// Looking for ' ' and then pass it
	if len(p.Rest) < 1 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 1, len(p.Rest), string(p.Rest))
	}
	pos = bytes.IndexByte(p.Rest[1:], ' ')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+1:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "' '", string(p.Rest[1:]))
	}

	return true, nil
}

// URL ...
type URL struct {
	Rest     []byte
	UserPass struct {
		Valid    bool
		User     []byte
		Password []byte
	}
	User struct {
		Valid bool
		User  []byte
	}
	Host   []byte
	Port   uint16
	DBName []byte
}

// Extract ...
func (p *URL) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var rest1 []byte
	var tmp []byte
	var tmpUint uint64
	rest1 = p.Rest

	// Take until ':' as User(string)
	if len(rest1) < 1 {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	pos = bytes.IndexByte(rest1[1:], ':')
	if pos >= 0 {
		p.UserPass.User = rest1[:pos+1]
		rest1 = rest1[pos+1+1:]
	} else {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}

	// Take until '@' as Password(string)
	if len(rest1) < 1 {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	pos = bytes.IndexByte(rest1[1:], '@')
	if pos >= 0 {
		p.UserPass.Password = rest1[:pos+1]
		rest1 = rest1[pos+1+1:]
	} else {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	p.UserPass.Valid = true
	p.Rest = rest1
urlUserPassLabel:
	rest1 = p.Rest

	// Take until '@' as User(string)
	if len(rest1) < 1 {
		p.User.Valid = false
		goto urlUserLabel
	}
	pos = bytes.IndexByte(rest1[1:], '@')
	if pos >= 0 {
		p.User.User = rest1[:pos+1]
		rest1 = rest1[pos+1+1:]
	} else {
		p.User.Valid = false
		goto urlUserLabel
	}
	p.User.Valid = true
	p.Rest = rest1
urlUserLabel:

	// Take until ':' as Host(string)
	if len(p.Rest) < 1 {
		return false, nil
	}
	pos = bytes.IndexByte(p.Rest[1:], ':')
	if pos >= 0 {
		p.Host = p.Rest[:pos+1]
		p.Rest = p.Rest[pos+1+1:]
	} else {
		return false, nil
	}

	// Take until '/' (or all the rest if not found) as Port(uint16)
	pos = bytes.IndexByte(p.Rest, '/')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		tmp = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Port(uint16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Port = uint16(tmpUint)

	// Take the rest as DBName(string)
	p.DBName = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// GetUserPassUser ...
func (p *URL) GetUserPassUser() (res []byte) {
	if p.UserPass.Valid {
		res = p.UserPass.User
	}
	return
}

// GetUserPassPassword ...
func (p *URL) GetUserPassPassword() (res []byte) {
	if p.UserPass.Valid {
		res = p.UserPass.Password
	}
	return
}

// GetUserUser ...
func (p *URL) GetUserUser() (res []byte) {
	if p.User.Valid {
		res = p.User.User
	}
	return
}

// IncludeChar ...
type IncludeChar struct {
	Rest   []byte
	Data   []byte
	Field2 int
}

// Extract ...
func (p *IncludeChar) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until '@' including it as Data(string)
	pos = bytes.IndexByte(p.Rest, '@')
	if pos >= 0 {
		p.Data = p.Rest[:pos+1]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '@' as Field2(int)
	pos = bytes.IndexByte(p.Rest, '@')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Field2(int): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Field2 = int(tmpInt)

	return true, nil
}

// IncludeString ...
type IncludeString struct {
	Rest   []byte
	Data   []byte
	Field2 int
}

// Extract ...
func (p *IncludeString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until "ab" including it  as Data(string)
	pos = bytes.Index(p.Rest, ab)
	if pos >= 0 {
		p.Data = p.Rest[:pos+len(ab)]
		p.Rest = p.Rest[pos+len(ab):]
	} else {
		return false, nil
	}

	// Take until "ab" as Field2(int)
	pos = bytes.Index(p.Rest, ab)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(ab):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Field2(int): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Field2 = int(tmpInt)

	return true, nil
}

// Hex ...
type Hex struct {
	Rest []byte
	F1   uint
	F2   uint8
	F3   uint16
	F4   uint32
	F5   uint64
}

// Extract ...
func (p *Hex) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until ' ' as F1(hex)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F1(hex): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F1 = uint(tmpUint)

	// Take until ' ' as F2(hex8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F2(hex8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F2 = uint8(tmpUint)

	// Take until ' ' as F3(hex16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F3(hex16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F3 = uint16(tmpUint)

	// Take until ' ' as F4(hex32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F4(hex32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F4 = uint32(tmpUint)

	// Take the rest as F5(hex64)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 16, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F5(hex64): %s", *(*string)(unsafe.Pointer(&p.Rest)), err)
	}
	p.F5 = uint64(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// Oct ...
type Oct struct {
	Rest []byte
	F1   uint
	F2   uint8
	F3   uint16
	F4   uint32
	F5   uint64
}

// Extract ...
func (p *Oct) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until ' ' as F1(oct)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F1(oct): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F1 = uint(tmpUint)

	// Take until ' ' as F2(oct8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F2(oct8): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F2 = uint8(tmpUint)

	// Take until ' ' as F3(oct16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 8); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F3(oct16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F3 = uint16(tmpUint)

	// Take until ' ' as F4(oct32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 32); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F4(oct32): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F4 = uint32(tmpUint)

	// Take the rest as F5(oct64)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 8, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F5(oct64): %s", *(*string)(unsafe.Pointer(&p.Rest)), err)
	}
	p.F5 = uint64(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// Dec ...
type Dec struct {
	Rest []byte
	F1   int32
	F2   int64
	F3   struct {
		Lo uint64
		Hi uint64
	}
}

// Extract ...
func (p *Dec) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte

	// Take until ' ' as F1(dec32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.F1, err = decconv.Decode32(8, 3, tmp); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F1(dec8.3): %s", string(tmp), err)
	}

	// Take until ' ' as F2(dec64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.F2, err = decconv.Decode64(12, 2, tmp); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F2(dec12.2): %s", string(tmp), err)
	}

	// Take the rest as F3(dec128)
	if p.F3.Lo, p.F3.Hi, err = decconv.Decode128(30, 8, p.Rest); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F3(dec30.8): %s", string(p.Rest), err)
	}
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// RestLength ...
type RestLength struct {
	Rest []byte
}

// Extract ...
func (p *RestLength) Extract(line []byte) (bool, error) {
	p.Rest = line

	// checks if the rest is exactly 15 characters long
	if len(p.Rest) != 15 {
		return false, nil
	}

	// checks if the rest is less than 16 characters long
	if len(p.Rest) >= 16 {
		return false, nil
	}

	// checks if the rest is more than 14 characters long
	if len(p.Rest) <= 14 {
		return false, nil
	}

	return true, nil
}

// Str ...
type Str struct {
	Rest []byte
	F1   string
	F2   []byte
}

// Extract ...
func (p *Str) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmp []byte

	// Take until ' ' as F1(str)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	p.F1 = string(tmp)

	// Take the rest as F2(string)
	p.F2 = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// Star ...
type Star struct {
	Rest []byte
	F    int
	B    int
}

// Extract ...
func (p *Star) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var headPassCounter int
	var headPassValue byte
	var pos int
	var tmp []byte
	var tmpInt int64

	// Pass all characters 'a' at the rest start
	for headPassCounter, headPassValue = range p.Rest {
		if headPassValue != 'a' {
			break
		}
	}
	if headPassCounter > 0 {
		p.Rest = p.Rest[headPassCounter:]
	}

	// Take until "|" as F(int)
	pos = bytes.Index(p.Rest, bar)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(bar):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field F(int): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.F = int(tmpInt)

	// Pass all characters 'a' at the rest start
	headPassCounter = 0
	for headPassCounter, headPassValue = range p.Rest {
		if headPassValue != 'a' {
			break
		}
	}
	if headPassCounter > 0 {
		p.Rest = p.Rest[headPassCounter:]
	}

	// Take the rest as B(int)
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&p.Rest)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field B(int): %s", *(*string)(unsafe.Pointer(&p.Rest)), err)
	}
	p.B = int(tmpInt)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// JustToCompile ...
type JustToCompile struct {
	Rest []byte
	Head uint16
	Tail uint16
}

// Extract ...
func (p *JustToCompile) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until 5th character if it is'-' as Head(hex16)
	if len(p.Rest) >= 4+1 && p.Rest[4] == '-' {
		pos = 4
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Head(hex16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Head = uint16(tmpUint)

	// Take the rest as Tail(hex16)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 16, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Tail(hex16): %s", *(*string)(unsafe.Pointer(&p.Rest)), err)
	}
	p.Tail = uint16(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// JustToCompileString ...
type JustToCompileString struct {
	Rest []byte
	Head uint16
	Tail uint16
}

// Extract ...
func (p *JustToCompileString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until 5th  if it starts "abcd" substring as Head(hex16)
	if len(p.Rest)-4 >= 4 && *(*uint64)(unsafe.Pointer(&p.Rest[4]))&0xffffffff == 0x64636261 {
		pos = 4
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(abcd):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Head(hex16): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Head = uint16(tmpUint)

	// Take the rest as Tail(hex16)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 16, 16); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Tail(hex16): %s", *(*string)(unsafe.Pointer(&p.Rest)), err)
	}
	p.Tail = uint16(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}
