package srcobj

import (
	"bytes"
	"fmt"
	"io"
	"sort"
	"strconv"
	"strings"

	"github.com/sirkon/errors"
	"github.com/sirkon/gosrcfmt"
	"github.com/sirkon/ldetool/internal/generator"
	"github.com/sirkon/message"
)

// File represents LDE generated Go source file
type File struct {
	pkgName   string
	imports   map[string]string
	strConsts map[string]string
	useString bool

	body *Body
}

// NewFile constructor
func NewFile(useString bool) *File {
	return &File{
		useString: useString,
		imports:   map[string]string{},
		strConsts: map[string]string{},
		body:      &Body{},
	}
}

// PkgName sets package name
func (f *File) PkgName(name string) {
	f.pkgName = name
}

// AddConst adds text constant and returns its name
func (f *File) AddConst(name, value string) string {
	suffix := ""
	i := 1
	for {
		candidate := name + suffix
		if val, ok := f.strConsts[candidate]; !ok {
			f.strConsts[candidate] = value
			return candidate
		} else if val == value {
			return candidate

		}
		i++
		suffix = fmt.Sprint(i)
	}
}

// AddNamedImport adds new import item with specific access name
func (f *File) AddNamedImport(access, path string) error {
	if prevAccess, ok := f.imports[path]; ok && prevAccess != access {
		return fmt.Errorf(
			`attempt to use "%s" as '%s' while it was added with '%s' access name before"`,
			path,
			access,
			prevAccess,
		)
	}
	f.imports[path] = access
	return nil
}

// AddExtractor adds new extractor struct type definition and returns struct body
func (f *File) AddExtractor(comment []string, typeName string, g generator.Generator) *Strct {
	st := structType{
		comment: comment,
		name:    typeName,
		s:       Struct(f.useString, g),
	}
	f.body.Append(st)
	return st.s
}

// AddExtract adds extraction method for an extractor
func (f *File) AddExtract(typeName string) *Method {
	res := NewExtractor(f.useString, typeName)
	f.body.Append(Raw("\n"))
	f.body.Append(res)
	return res
}

// AddAccessor adds accessor method for an extractor
func (f *File) AddAccessor(typeName, name string, resultType hardToAccessResultType) *Method {
	res := NewAccessor(typeName, name, resultType)
	f.body.Append(res)
	return res
}

// Dump ...
func (f *File) Dump(w io.Writer) error {
	if len(f.pkgName) == 0 {
		return fmt.Errorf("package name is not set, use PkgName")
	}

	buf := &bytes.Buffer{}
	if _, err := fmt.Fprintf(buf, "package %s\n", f.pkgName); err != nil {
		return err
	}
	if _, err := io.WriteString(buf, "import (\n"); err != nil {
		return err
	}

	imports := []string{}
	for k := range f.imports {
		imports = append(imports, k)
	}
	sort.Sort(sort.StringSlice(imports))
	for _, k := range imports {
		access := f.imports[k]
		if _, err := fmt.Fprintf(buf, `%s "%s"`, access, k); err != nil {
			return err
		}
		if _, err := io.WriteString(buf, "\n"); err != nil {
			return err
		}
	}
	if _, err := io.WriteString(buf, ")\n"); err != nil {
		return err
	}

	vars := []string{}
	for n := range f.strConsts {
		vars = append(vars, n)
	}
	sort.Sort(sort.StringSlice(vars))
	var conversion string
	if f.useString {
		conversion = "%s"
	} else {
		conversion = "[]byte(%s)"
	}
	for _, varName := range vars {
		value := f.strConsts[varName]
		if _, err := fmt.Fprintf(buf, "var %s = "+conversion+"\n", varName, value); err != nil {
			return err
		}
	}

	if err := f.body.Dump(buf); err != nil {
		return err
	}

	return func() (err error) {
		defer func() {
			var ok bool
			if r := recover(); r != nil {
				err, ok = r.(error)
				if !ok {
					err = fmt.Errorf("%s", r)
				}
			}
		}()

		res, err := gosrcfmt.Autogen(buf.Bytes())
		if err != nil {
			lines := strings.Split(buf.String(), "\n")
			format := "%0" + strconv.Itoa(len(strconv.Itoa(len(lines)))) + "d %s"
			for i, line := range lines {
				// need to use i + 3 as gosrcfmt.Autogen puts 3 lines in the head
				message.Errorf(format, i+3, line)
			}

			return errors.Wrap(err, "format autogenerated code")
		}
		if _, err := io.Copy(w, bytes.NewBuffer(res)); err != nil {
			return errors.Wrap(err, "write autogenerated code")
		}
		return
	}()
}

// Append appends to file body
func (f *File) Append(src Source) {
	f.body.Append(src)
}
